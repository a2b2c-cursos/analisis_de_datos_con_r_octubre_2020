#R permite graficar tipo mosaico, así podemos graficar los dos juntos
#La función layout recibe una matriz y grafica un mosaico en función de la cantidad de filas
#y columnas que tiene esa matriz
mosaico_layout <- matrix(1:2, ncol=1, nrow = 2)
layout(mosaico_layout)
hist(secuencias_largas)
boxplot(secuencias_largas, horizontal = T) #Graficamos el boxplot horizontal para comparar
#R permite graficar tipo mosaico, así podemos graficar los dos juntos
#La función layout recibe una matriz y grafica un mosaico en función de la cantidad de filas
#y columnas que tiene esa matriz
mosaico_layout <- matrix(1:2, ncol=2, nrow = 1)
layout(mosaico_layout)
hist(secuencias_largas)
boxplot(secuencias_largas, horizontal = T) #Graficamos el boxplot horizontal para comparar
dev.off()
#R permite graficar tipo mosaico, así podemos graficar los dos juntos
#La función layout recibe una matriz y grafica un mosaico en función de la cantidad de filas
#y columnas que tiene esa matriz
mosaico_layout <- matrix(1:2, ncol=2, nrow = 1)
layout(mosaico_layout)
hist(secuencias_largas)
boxplot(secuencias_largas, horizontal = T) #Graficamos el boxplot horizontal para comparar
#R permite graficar tipo mosaico, así podemos graficar los dos juntos
#La función layout recibe una matriz y grafica un mosaico en función de la cantidad de filas
#y columnas que tiene esa matriz
mosaico_layout <- matrix(1:4, ncol=2, nrow = 2)
layout(mosaico_layout)
hist(secuencias_largas)
boxplot(secuencias_largas, horizontal = T) #Graficamos el boxplot horizontal para comparar
dev.off()
#R permite graficar tipo mosaico, así podemos graficar los dos juntos
#La función layout recibe una matriz y grafica un mosaico en función de la cantidad de filas
#y columnas que tiene esa matriz
mosaico_layout <- matrix(1:4, ncol=2, nrow = 2)
layout(mosaico_layout)
hist(secuencias_largas)
boxplot(secuencias_largas, horizontal = T) #Graficamos el boxplot horizontal para comparar
hist(secuencias_largas)
boxplot(secuencias_largas, horizontal = T) #Graficamos el boxplot horizontal para comparar
#R permite graficar tipo mosaico, así podemos graficar los dos juntos
#La función layout recibe una matriz y grafica un mosaico en función de la cantidad de filas
#y columnas que tiene esa matriz
dev.new()
mosaico_layout <- matrix(1:4, ncol=2, nrow = 2)
layout(mosaico_layout)
hist(secuencias_largas)
boxplot(secuencias_largas, horizontal = T) #Graficamos el boxplot horizontal para comparar
hist(secuencias_largas)
boxplot(secuencias_largas, horizontal = T) #Graficamos el boxplot horizontal para comparar
dev.off()
#R permite graficar tipo mosaico, así podemos graficar los dos juntos
#La función layout recibe una matriz y grafica un mosaico en función de la cantidad de filas
#y columnas que tiene esa matriz
dev.new()
mosaico_layout <- matrix(1:4, ncol=2, nrow = 2)
layout(mosaico_layout)
hist(secuencias_largas)
boxplot(secuencias_largas, horizontal = T) #Graficamos el boxplot horizontal para comparar
hist(secuencias_largas)
boxplot(secuencias_largas, horizontal = T) #Graficamos el boxplot horizontal para comparar
mosaico_layout <- matrix(1:4, ncol=2, nrow = 2)
mosaico_layout
mosaico_layout <- matrix(1:4, ncol=2, nrow = 2, byrow = T)
mosaico_layout
hist(secuencias_largas)
boxplot(secuencias_largas, horizontal = T) #Graficamos el boxplot horizontal para comparar
mosaico_layout <- matrix(1:4, ncol=2, nrow = 2, byrow = T)
layout(mosaico_layout)
hist(secuencias_largas)
boxplot(secuencias_largas, horizontal = T) #Graficamos el boxplot horizontal para comparar
hist(secuencias_largas)
boxplot(secuencias_largas, horizontal = T) #Graficamos el boxplot horizontal para comparar
hist(secuencias_largas)
boxplot(secuencias_largas, horizontal = T) #Graficamos el boxplot horizontal para comparar
mosaico_layout <- matrix(1:4, ncol=2, nrow = 2, byrow = T)
layout(mosaico_layout)
hist(secuencias_largas)
boxplot(secuencias_largas, horizontal = T) #Graficamos el boxplot horizontal para comparar
hist(secuencias_largas)
boxplot(secuencias_largas, horizontal = T) #Graficamos el boxplot horizontal para comparar
hist(secuencias_largas)
boxplot(secuencias_largas, horizontal = T) #Graficamos el boxplot horizontal para comparar
#Volvemos al layout convencional
layout(1)
plot(1, 1)
x <- seq(-pi, pi, 0.1)
y <- sin(x)
#R permite graficar tipo mosaico, así podemos graficar los dos juntos
#La función layout recibe una matriz y grafica un mosaico en función de la cantidad de filas
#y columnas que tiene esa matriz
#dev.new()
mosaico_layout <- matrix(1:4, ncol=2, nrow = 2, byrow = T)
layout(mosaico_layout)
hist(secuencias_largas)
boxplot(secuencias_largas, horizontal = T) #Graficamos el boxplot horizontal para comparar
x <- seq(-pi, pi, 0.1)
y <- sin(x)
plot(x, y)
secuencias_largas
secuencias_largas
#Volvamos a la moda. La moda es el valor que más veces aparece. Para calcularla tenemos que contar
#cuantas veces aparece cada valor y quedarnos con el que más veces aparezca.
#Usamos table para contar y which.max para que nos diga cual es el valor que más aparece
cuantas_veces_aparece_cada_valor <- table(secuencias_largas)
cuantas_veces_aparece_cada_valor
which.max(cuantas_veces_aparece_cada_valor)
v <- c(1, 2, 3, 4, 5)
v == 3
v <- c(1, 2, 3, 4, 5, 3)
v == 3
which(v == 3)
which.max(cuantas_veces_aparece_cada_valor)
max(cuantas_veces_aparece_cada_valor)
cuantas_veces_aparece_cada_valor[which.max(cuantas_veces_aparece_cada_valor)]
class(cuantas_veces_aparece_cada_valor)
print(cuantas_veces_aparece_cada_valor)
names(cuantas_veces_aparece_cada_valor)
nombresDeLaTabla <- names(cuantas_veces_aparece_cada_valor)
median(secuencias_largas)
mean(secuencias_largas)
cuantas_veces_aparece_cada_valor[which.max(cuantas_veces_aparece_cada_valor)]
hist(secuencias_largas)
dev.off()
hist(secuencias_largas)
IQR(secuencias_largas)
sd(secuencias_largas)
casos_covid_secuenciados$a
#------------------------------------------------------------------------------------
#Ejercicios:
#casos_covid_secuenciados$a
#1-Caractericen la variable "a" y en caso de detectar valores extremos
#elegir un criterio para removerlos.
#2-Encuentren cuantas secuencias hay de cada país.
#------------------------------------------------------------------------------------
hist(casos_covid_secuenciados$a)
a_largos <- casos_covid_secuenciados$a[casos_covid_secuenciados$a > 4000]
a_largos
boxplot(casos_covid_secuenciados$a)
IQR(casos_covid_secuenciados$a)
boxplot(casos_covid_secuenciados$a, horizontal = T)
iqr <- IQR(casos_covid_secuenciados$a)
iqr
quantile(casos_covid_secuenciados$a, probs = 0.25)
summary(casos_covid_secuenciados$a)
primer_cuartil <- quantile(casos_covid_secuenciados$a, probs = 0.25)
minimo <- primer_cuartil - 1.5*iqr
valor_de_corte <- primer_cuartil - 1.5*iqr
valor_de_corte
a_largos <- casos_covid_secuenciados$a[casos_covid_secuenciados$a > valor_de_corte]
hist(a_largos)
View(casos_covid_secuenciados)
#Podemos ver cuantas secuencias hay por ubicación
table(casos_covid_secuenciados$Location)
#Si queremos ver por país, vamos a tener que procesar las ubicaciones, quedándonos únicamente con la parte del país
#Usamos strsplit para partir la cadena, lapply para quedarnos con la primera parte y unlist para obtener finalmente
#un vector
head(casos_covid_secuenciados$Location, n = 10)
paises <- strsplit(casos_covid_secuenciados$Location, " / ", fixed = F)
head(paises)
class(paises)
#Con R podemos aplicar una misma función a cada elemento de la lista
primerItem <- function(v){
return(v[1])
}
#Veamos como funciona primerItem
vectorDePrueba <- c("Curso", "De", "R")
vectorDePrueba
primerItem(vectorDePrueba)
paises
paises[[1]]
paises[1]
class(paises[1])
v <- paises[[1]]
v
primerItem(v)
v <- paises[[2]]
primerItem(v)
v <- paises[[3]]
primerItem(v)
v <- paises[[550]]
primerItem(v)
v <- paises[[1:5]]
v <- paises[1:5]
v
v <- paises[[1:5]]
v <- paises[[550]]
primerItem(v)
#Apliquemos primerItem a cada elemento de la lista para obtener los países
paises <- lapply(paises, primerItem)
paises
class(paises)
#Sigue siendo una lista, podemos "desenlistarla"
paises <- unlist(paises)
paises
#Encontremos la cantidad de secuencias por país
table(casos_covid_secuenciados$pais)
table(paises)
#Podemos agregarlo como columna del dataframe para usarlo si lo necesitamos después
casos_covid_secuenciados$pais <- paises
#Encontremos la cantidad de secuencias por país
table(casos_covid_secuenciados$pais)
#En lugar de caracterizar cada variable por separado, nos puede interesar comparar
#distintas variables entre si. Por ejemplo, podemos querer comparar su distribución y
#sus medias y varianzas o encontrar relaciones entre los mismos.
#Veamos qué pasa con a, c, g y t. Pero primero, eliminemos todas las muestras
#de secuencias cortas. Podemos usar varios criterios para esto, por ejemplo, el de los bigotes del
#boxplot. Nos quedamos con las secuencias que sean mayores que primer cuartil - 1.5*IQR
primer_cuartil <- quantile(casos_covid_secuenciados$Sequence.Length, probs = 0.25)
iqr            <- IQR(casos_covid_secuenciados$Sequence.Length)
ids_secuencias_largas <- which(casos_covid_secuenciados$Sequence.Length > (primer_cuartil-1.5*iqr))
acgt <- casos_covid_secuenciados[ids_secuencias_largas, c("a", "c", "g", "t")]
acgt
summary(acgt)
#podemos graficar un boxplot por cada uno rapidamente
dim(acgt)
boxplot(acgt)
#Vemos que las 4 bases tienen distribuciones diferentes.
#¿Existirá relación entre ellas? Veamos que pasa con c y t. Podemos agregar titulo, nombrar los ejes y jugar con los límites.
plot(acgt$c, acgt$t, main = "c vs. t", xlab = "c (bases)", ylab="t (bases)", xlim=c(5400, 5500), ylim=c(9500, 9600))
plot(1, 1)
plot(c(1, 2), 1)
plot(c(1, 2), c(1, 5))
plot(acgt$c, acgt$t)
plot(acgt$c, acgt$t, xlim=c(5400, 5500), ylim=c(9500, 9600))
plot(acgt$c, acgt$t, xlim=c(5400, 5500), ylim=c(9500, 9600), main = "c vs. t")
plot(acgt$c, acgt$t, xlim=c(5400, 5500), ylim=c(9500, 9600), main = "c vs. t", xlab = "c (bases)", ylab = "t (bases)")
plot(acgt$c, acgt$t, xlim=c(5400, 5500), ylim=c(9500, 9600), main = "c vs. t", xlab = "c (#bases)", ylab = "t (#bases)")
#Pareciera haber una relación lineal creciente entre ambas
#Veamos todas contra todas
pairs(acgt)
?pairs
#Pareciera haber una relación lineal creciente entre ambas
#Veamos todas contra todas
pairs(acgt)
#Todas tienen una relación lineal creciente.
#¿Descubrimos nueva biología o qué puede estar pasando?
#Agreguemos la longitud de la secuencia
plot(casos_covid_secuenciados[ids_secuencias_largas, c("Sequence.Length", "a")], main = "Longitud de secuencia vs. a", xlab = "Longitud de secuencia", ylab="a")
#Parece haber una relación lineal creciente también, pero la escala no ayuda
#Cortemos el gráfico
plot(casos_covid_secuenciados[ids_secuencias_largas, c("Sequence.Length", "a")], ylim=c(8500, 9000))
#¿Todas se comportan igual?
pairs(casos_covid_secuenciados[ids_secuencias_largas, c("Sequence.Length", "a", "c", "g", "t")])
#Veamos como son los perfiles de secuencias.
#Usamos matplot para graficar las coordenadas paralelas. Tenemos que transponer
#el dataframe para que tome las columnas como variables, y le decimos que el type
#sea "l" para que grafique segmentos
matplot(t(casos_covid_secuenciados[ids_secuencias_largas, c("an", "cn", "gn", "tn")]), type="l")
#Veamos como son los perfiles de secuencias.
#Usamos matplot para graficar las coordenadas paralelas. Tenemos que transponer
#el dataframe para que tome las columnas como variables, y le decimos que el type
#sea "l" para que grafique segmentos
matplot(t(casos_covid_secuenciados[ids_secuencias_largas, c("an", "cn", "gn", "tn")]), type="l", col = "black")
length(ids_secuencias_largas)
legend()
x <- seq(-pi, pi, 0.1)
y <- sin(x)
plot(x, y)
legend(legend = c("Seno x"))
legend("bottomleft", legend = c("Seno x"))
legend("bottomright", legend = c("Seno x"))
legend("bottomright", legend = c("Seno x"))
plot(x, y)
legend("bottomright", legend = c("Seno x"))
legend("bottomright", legend = c("Seno x"), pch = 18)
legend("bottomright", legend = c("Seno x"), pch = 19)
legend("bottomright", legend = c("Seno x"), pch = 20)
legend("bottomright", legend = c("Seno x"), pch = 15)
legend("bottomright", legend = c("Seno x"), pch = 14)
legend("bottomright", legend = c("Seno x"), pch = 11)
legend("bottomright", legend = c("Seno x"), pch = 10)
legend("bottomright", legend = c("Seno x"), pch = 10, b = 'n')
legend("bottomright", legend = c("Seno x"), pch = 10)
legend("bottomright", legend = c("Seno x"), pch = 10, text.font = "arial")
plot(x, y, pch = 15)
?plot
legend("bottomright", legend = c("Seno x"), pch = 10, text.font = "arial")
legend("bottomright", legend = c("Seno x"), pch = 10, text.font = "arial")
plot(x, y, pch = 15)
legend("bottomright", legend = c("Seno x"), pch = 10, text.font = "arial")
legend("bottomright", legend = c("Seno x"), pch = 15)
#Usemos R como un simulador. Simulemos tirar un dado miles de veces. La función sample va a venir en
#nuestra ayuda para esto.
?sample
#Las computadoras son máquinas deterministas, ante la misma entrada siempre devuelven la misma salida.
#Si queremos simular azar, necesitamos un generador de números pseudo-aleatorios.
#Los generadores de números pseudo-aleatorios necesitan un lugar desde donde comenzar a producir
#los números y eso se lo decimos a R usando set.seed
#Un poco más de información para los curiosos: https://es.wikipedia.org/wiki/Generador_de_n%C3%BAmeros_pseudoaleatorios
set.seed(123457)
#Fabriquemos un dado y tirémoslo varias veces
dado <- 1:6
dado
sample(x = dado, size = 1)
sample(x = dado, size = 1)
sample(x = dado, size = 1)
sample(x = dado, size = 1)
#Las computadoras son máquinas deterministas, ante la misma entrada siempre devuelven la misma salida.
#Si queremos simular azar, necesitamos un generador de números pseudo-aleatorios.
#Los generadores de números pseudo-aleatorios necesitan un lugar desde donde comenzar a producir
#los números y eso se lo decimos a R usando set.seed
#Un poco más de información para los curiosos: https://es.wikipedia.org/wiki/Generador_de_n%C3%BAmeros_pseudoaleatorios
set.seed(123457)
sample(x = dado, size = 1)
sample(x = dado, size = 1)
sample(x = dado, size = 1)
sample(x = dado, size = 1)
set.seed(123457)
sample(x = dado, size = 1)
set.seed(123457)
sample(x = dado, size = 1)
set.seed(123457)
sample(x = dado, size = 1)
set.seed(123457)
sample(x = dado, size = 1)
dado <- c("A", "B")
sample(x = dado, size = 1)
#Las computadoras son máquinas deterministas, ante la misma entrada siempre devuelven la misma salida.
#Si queremos simular azar, necesitamos un generador de números pseudo-aleatorios.
#Los generadores de números pseudo-aleatorios necesitan un lugar desde donde comenzar a producir
#los números y eso se lo decimos a R usando set.seed
#Un poco más de información para los curiosos: https://es.wikipedia.org/wiki/Generador_de_n%C3%BAmeros_pseudoaleatorios
set.seed(9)
#Fabriquemos un dado y tirémoslo varias veces
dado <- 1:6
dado
sample(x = dado, size = 1)
sample(x = dado, size = 1)
sample(x = dado, size = 1)
sample(x = dado, size = 1)
#Las computadoras son máquinas deterministas, ante la misma entrada siempre devuelven la misma salida.
#Si queremos simular azar, necesitamos un generador de números pseudo-aleatorios.
#Los generadores de números pseudo-aleatorios necesitan un lugar desde donde comenzar a producir
#los números y eso se lo decimos a R usando set.seed
#Un poco más de información para los curiosos: https://es.wikipedia.org/wiki/Generador_de_n%C3%BAmeros_pseudoaleatorios
set.seed(9)
sample(x = dado, size = 1)
sample(x = dado, size = 1)
sample(x = dado, size = 1)
sample(x = dado, size = 1)
#Las computadoras son máquinas deterministas, ante la misma entrada siempre devuelven la misma salida.
#Si queremos simular azar, necesitamos un generador de números pseudo-aleatorios.
#Los generadores de números pseudo-aleatorios necesitan un lugar desde donde comenzar a producir
#los números y eso se lo decimos a R usando set.seed
#Un poco más de información para los curiosos: https://es.wikipedia.org/wiki/Generador_de_n%C3%BAmeros_pseudoaleatorios
set.seed(123457)
#Las computadoras son máquinas deterministas, ante la misma entrada siempre devuelven la misma salida.
#Si queremos simular azar, necesitamos un generador de números pseudo-aleatorios.
#Los generadores de números pseudo-aleatorios necesitan un lugar desde donde comenzar a producir
#los números y eso se lo decimos a R usando set.seed
#Un poco más de información para los curiosos: https://es.wikipedia.org/wiki/Generador_de_n%C3%BAmeros_pseudoaleatorios
set.seed(123457)
#Fabriquemos un dado y tirémoslo varias veces
dado <- 1:6
dado
sample(x = dado, size = 1)
sample(x = dado, size = 1)
sample(x = dado, size = 1)
sample(x = dado, size = 1)
#Ahora tiremos dos dados
sample(dado, 2, replace=T)
sample(dado, 2, replace=T)
sample(dado, 2, replace=T)
sample(dado, 2, replace=T)
#Tiramos diez veces los dos dados. Podríamos usar un for pero r nos ayuda usando replicate
?replicate
#Fabrico el dado
dado <- 1:6
#Lo tiro dos veces
tirada <- sample(dado, 2, replace=T)
tirada
#Fabriquemos una función que tire los dos dados. Fijensé que una función no necesariamente requiere
#un parámetro
dosDados <- function(){
#Fabrico el dado
dado <- 1:6
#Lo tiro dos veces
tirada <- sample(dado, 2, replace=T)
#Devuelvo la tirada
return(tirada)
}
#Tiremos los dados diez veces
diez_tiradas <- replicate(n = 10, dosDados())
diez_tiradas
?t
diez_tiradas <- t(diez_tiradas)
diez_tiradas
suma_de_las_caras <- rowSums(diez_tiradas)
suma_de_las_caras
#¿Es igual de probable sacar cualquier número? Contemos cuantas veces aparece cada número.
table(suma_de_las_caras)
#¿Si corremos esto de nuevo obtenemos el mismo resultado?
diez_tiradas <- replicate(10, dosDados())
diez_tiradas <- t(diez_tiradas)
suma_de_las_caras2 <- rowSums(diez_tiradas)
#Comparemos con la tirada anterior
table(suma_de_las_caras)
table(suma_de_las_caras2)
#¿Cómo podemos intentar estimar la probabilidad real de que salga cada número?
#Si tiramos muchas veces y contamos cuantas veces
#da cada resultado nos podemos acercar bastante al valor real
diezmil_tiradas <- replicate(10000, dosDados())
#¿Cómo podemos intentar estimar la probabilidad real de que salga cada número?
#Si tiramos muchas veces y contamos cuantas veces
#da cada resultado nos podemos acercar bastante al valor real
diezmil_tiradas <- replicate(10000, dosDados())
#¿Cómo podemos intentar estimar la probabilidad real de que salga cada número?
#Si tiramos muchas veces y contamos cuantas veces
#da cada resultado nos podemos acercar bastante al valor real
diezmil_tiradas <- replicate(1000000, dosDados())
#¿Cómo podemos intentar estimar la probabilidad real de que salga cada número?
#Si tiramos muchas veces y contamos cuantas veces
#da cada resultado nos podemos acercar bastante al valor real
diezmil_tiradas <- replicate(10000, dosDados())
#¿Cómo podemos intentar estimar la probabilidad real de que salga cada número?
#Si tiramos muchas veces y contamos cuantas veces
#da cada resultado nos podemos acercar bastante al valor real
diezmil_tiradas <- replicate(1000000, dosDados())
#¿Cómo podemos intentar estimar la probabilidad real de que salga cada número?
#Si tiramos muchas veces y contamos cuantas veces
#da cada resultado nos podemos acercar bastante al valor real
diezmil_tiradas <- replicate(1000000, dosDados())
#¿Cómo podemos intentar estimar la probabilidad real de que salga cada número?
#Si tiramos muchas veces y contamos cuantas veces
#da cada resultado nos podemos acercar bastante al valor real
diezmil_tiradas <- replicate(10000, dosDados())
diezmil_tiradas <- t(diezmil_tiradas)
head(diezmil_tiradas)
suma_de_las_caras <- rowSums(diezmil_tiradas)
table(suma_de_las_caras)
#Calculemos la probabilidad estimada de cada número. Esto lo podemos pensar como el porcentaje de
#veces que salió cada uno
probabilidad_estimada <- table(suma_de_las_caras)/length(suma_de_las_caras)
probabilidad_estimada
1681/10000
#La posta se puede calcular (¿cómo?) y es la siguiente:
probabilidad_real <- c(1/36, 2/36, 3/36, 4/36, 5/36, 6/36, 5/36, 4/36, 3/36, 2/36, 1/36)
probabilidad_estimada
#Grafiquemos la probabilidad estimada y la probabilidad real
plot(probabilidad_estimada, xlab="x", ylab = "P", main="Distribución (estimada) de probabilidad de 'suma de las caras'")
points(2:12, probabilidad_real, col = "red")
head(diezmil_tiradas)
head(t(diezmil_tiradas))
head(diezmil_tiradas)
suma_de_las_caras <- rowSums(diezmil_tiradas)
suma_de_las_caras
#Calculemos la probabilidad estimada de cada número. Esto lo podemos pensar como el porcentaje de
#veces que salió cada uno
probabilidad_estimada <- table(suma_de_las_caras)/length(suma_de_las_caras)
#Grafiquemos la probabilidad estimada y la probabilidad real
plot(probabilidad_estimada, xlab="x", ylab = "P", main="Distribución (estimada) de probabilidad de 'suma de las caras'")
points(2:12, probabilidad_real, col = "red")
points(2:12, probabilidad_real, col = "red")
#Grafiquemos la probabilidad estimada y la probabilidad real
plot(probabilidad_estimada, xlab="x", ylab = "P", main="Distribución (estimada) de probabilidad de 'suma de las caras'")
points(2:12, probabilidad_real, col = "red")
class(suma_de_las_caras)
class(suma_de_las_caras >= 3)
head(suma_de_las_caras >= 3)
class(suma_de_las_caras >= 3 & suma_de_las_caras <= 7)
#¿Cómo calcularían la probabilidad de que la suma de entre 3 y 7?
entre <- suma_de_las_caras >= 3 & suma_de_las_caras <= 7
head(entre)
head(suma_de_las_caras)
c(T, F, T)
sum(c(T, F, T))
sum(c(T, F, T, F, T))
sum(entre)
sum(entre)/length(suma_de_las_caras)
#¿Dará lo mismo si sumamos las probabilidades de que salga cada número, desde el 3 al 7?
probabilidad_estimada
sum(probabilidad_estimada[c("3", "4", "5", "6", "7")])
sum(entre)/length(suma_de_las_caras)
#¿Y cuanto da la probabilidad de que salga cualquiera de los números desde el 2 al 12?
sum(probabilidad_estimada)
#Veamos como podemos simular otras distribuciones con R. Exploremos la función runif a ver qué devuelve.
#Primero reiniciemos el generador de números aleatorios
set.seed(123457)
runif(n = 1)
runif(n = 1)
runif(n = 1)
runif(n = 1)
#Corramos 100 veces runif con replicate y grafiquemos un histograma de lo que obtuvimos
unif <- replicate(100, runif(n = 1))
hist(unif)
hist(unif)
#Corramos 1000 veces runif con replicate y grafiquemos un histograma de lo que obtuvimos
unif <- replicate(1000, runif(n = 1))
#Corramos 100 veces runif con replicate y grafiquemos un histograma de lo que obtuvimos
unif <- replicate(100, runif(n = 1))
hist(unif)
#Corramos 1000 veces runif con replicate y grafiquemos un histograma de lo que obtuvimos
unif <- replicate(1000, runif(n = 1))
hist(unif)
#runif viene con su propio replicate incorporado, podemos pedirle 100000 números directamente. Grafiquemos un histograma de lo que obtuvimos.
unif <- runif(100000)
hist(unif)
hist(unif/10000)
#runif viene con su propio replicate incorporado, podemos pedirle 100000 números directamente. Grafiquemos un histograma de lo que obtuvimos.
unif <- runif(100000)
hist(unif)
#Veamos cuántos números hay menores a 0.5. ¿Cuántos números esperan?
menores <- unif < 0.5
head(menores)
length(menores)
table(menores)
#¿Y menores a 0.95?.
menores <- unif < 0.95
table(menores)
#¿Y entre 0.25 y 0.75? ¿Qué porcentaje tiene?.
entre <- unif > 0.25 & unif < 0.75
table(entre)/length(unif)
